//
// eeprom.h
// 	This is part of rustyrig-fw. https://github.com/pripyatautomations/rustyrig-fw
//
// Do not pay money for this, except donations to the project, if you wish to.
// The software is not for sale. It is freely available, always.
//
// Licensed under MIT license, if built without mongoose or GPL if built with.
#if	!defined(___rr_eeprom_h)
#define	__rr_eeprom_h

// This will prevent loading with a newer EEPROM version and someday will force an upgrade if older
#define	MY_EEPROM_VER	1

#include "config.h"
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include "state.h"
#include "eeprom_types.h"

#define	PIN_LEN	8		// 8 byte pin

typedef enum mod_mode {
    MOD_NONE = 0,
    MOD_CW,
    MOD_LSB,
    MOD_USB,
    MOD_AM,
    MOD_FM,
    MOD_DIGI,
    MOD_C4FM
} mod_mode;

struct eeprom_layout {
    char 		*key;
    size_t		offset;		// Offset into rom
    size_t 		size;		// Size in bytes
    ee_data_type 	type;		// this is generated by buildconf.pl as build/$profile/eeprom_types.h
};

struct eeprom_channel_groups {		// Channel group names
    int			id;
    char		name[13];
};
typedef struct eeprom_channel_group ee_chan_group;

struct eeprom_channel_header {		// Header data for the channel memory
    int			total_slots;	// Allocated slots in eeprom
    int			used_slots;	// Used slots in eeprom
};
typedef struct eeprom_channel_header ee_cha_hdr;

struct eeprom_channel_slot {		// An indvidual channel slot
    int			group;		// Channel Group or -1 if none
    char		name[29];	// Name string
    float		freq;		// Frequency in khz
    char		mode[5];	// Modulation mode
//    enum mod_mode	mode;		// Modulation Mode (stored as 4 byte string in eeprom)
    int			bw;		// bw in hz
    int			split_dir;	// Split direction: -1 for negative, 0 or 1 for normal
    float		tx_offset;	// Transmit offset in Khz (for repeaters)
    char		pl_mode[5];	// PL mode (4 bytes)
    int			tx_dcs;
    int			rx_dcs;
    int			tx_pl;
    int			rx_pl;
    float		tx_power;	// TX power in watts
    int			agc;
    int			nb;
    int			rf_gain;
};
typedef struct eeprom_channel_slot ee_chan_slot;

// Support for deal with eeprom by name instead of addresses
extern uint32_t eeprom_offset_index(const char *key);
extern const char *eeprom_offset_name(uint32_t idx);

// Direct (by address) reading of one or more bytes
// These should only be used internally...
extern void *eeprom_read(size_t offset);
extern uint32_t eeprom_write(size_t offset, u_int8_t data);
extern uint32_t eeprom_read_block(u_int8_t *buf, size_t offset, size_t len);
extern uint32_t eeprom_write_block(void *buf, size_t offset, size_t len);

// This is the API intended to be used, to abstract out platform differences
extern uint32_t eeprom_init(void);
extern uint32_t eeprom_load_config(void);
extern uint32_t eeprom_write_config(uint32_t force);
extern uint32_t eeprom_get_int(const char *key);
extern uint32_t eeprom_get_int_i(uint32_t idx);
extern const char *eeprom_get_str(const char *key);
extern const char *eeprom_get_str_i(uint32_t idx);
extern bool eeprom_get_bool(const char *key);
extern bool eeprom_get_bool_i(uint32_t idx);
extern float eeprom_get_float(const char *key);
extern float eeprom_get_float_i(uint32_t idx);
extern uint32_t get_serial_number(void);
extern struct in_addr *eeprom_get_ip4(const char *key, struct in_addr *sin);
extern void show_pin_info(void);

#endif	// !defined(__rr_eeprom_h)
