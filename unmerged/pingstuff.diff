diff --git a/auth.c b/auth.c
index 00650aa..0ed53d8 100644
--- a/auth.c
+++ b/auth.c
@@ -383,10 +383,10 @@ bool ws_handle_auth_msg(struct mg_ws_message *msg, struct mg_connection *c) {
       char resp_buf[HTTP_WS_MAX_MSG+1];
       memset(resp_buf, 0, sizeof(resp_buf));
 
-
       Log(LOG_AUDIT, "auth", "Login request from user %s on mg_conn:<%x> from %s:%d", user, c, ip, port);
 
-      http_client_t *cptr = http_add_client(c, true);
+      http_client_t *cptr = MG_CONN_CPTR(c);
+
       if (cptr == NULL) {
          Log(LOG_CRIT, "auth", "Discarding login request on mg_conn:<%x> from %s:%d due to NULL cptr?!?!!?", c, ip, port);
          rv = true;
@@ -505,6 +505,8 @@ bool ws_handle_auth_msg(struct mg_ws_message *msg, struct mg_connection *c) {
 
          // Send a ping to the user and expect them to reply within HTTP_PING_TIMEOUT seconds
          ws_send_ping(cptr);
+         // Set allast heard time to now, since can be reasonably sure the connection is alive
+         cptr->last_heard = now;
 
          // blorp out a join to all chat users
          memset(resp_buf, 0, sizeof(resp_buf));
diff --git a/http.c b/http.c
index 8d4f89f..d039ede 100644
--- a/http.c
+++ b/http.c
@@ -359,7 +359,10 @@ static void http_cb(struct mg_connection *c, int ev, void *ev_data) {
    }
 
    if (ev == MG_EV_ACCEPT) {
-//      Log(LOG_AUDIT, "http", "Accepted connection on mg_conn:<%x> from %s:%d", c, ip, port);
+      Log(LOG_CRAZY, "http", "Accepted connection on mg_conn:<%x> from %s:%d", c, ip, port);
+      http_client_t *cptr = http_add_client(c, false);
+      MG_CONN_CPTR(c) = cptr;
+      Log(LOG_DEBUG, "http", "c:<%x> cptr:<%x>", c, cptr);
 
 #if	defined(HTTP_USE_TLS)
       if (c->fn_data != NULL) {
@@ -376,9 +379,10 @@ static void http_cb(struct mg_connection *c, int ev, void *ev_data) {
 
      if (cptr) {
         Log(LOG_INFO, "http", "Conn mg_conn:<%x> from %s:%d upgraded to ws with cptr:<%x>", c, ip, port, cptr);
+        cptr->is_ws = true;
      } else {
-        // XXX: We should kick the user if no cptr, i think??
         Log(LOG_CRIT, "http", "Conn mg_conn:<%x> from %s:%d upgraded to ws", c, ip, port);
+        ws_kick_client_by_c(c, "Data error");
      }
    } else if (ev == MG_EV_WS_MSG) {
      struct mg_ws_message *msg = (struct mg_ws_message *)ev_data;
@@ -487,6 +491,7 @@ http_client_t *http_add_client(struct mg_connection *c, bool is_ws) {
    // create some randomness for login hashing and session
    generate_nonce(cptr->token, sizeof(cptr->token));
    generate_nonce(cptr->nonce, sizeof(cptr->nonce));
+   cptr->connected = now;
    cptr->authenticated = false;
    cptr->active = true;
    cptr->conn = c;
@@ -542,6 +547,10 @@ bool ws_send_ping(http_client_t *cptr) {
       return true;
    }
 
+   if (!cptr->is_ws) {
+      return true;
+   }
+
    // XXX: Send a ping, so they'll have something to respond to, to acknowledge life
    char resp_buf[HTTP_WS_MAX_MSG+1];
    struct mg_connection *c = cptr->conn;
@@ -550,45 +559,49 @@ bool ws_send_ping(http_client_t *cptr) {
       return true;
    }
 
+   cptr->last_ping = now;
+   Log(LOG_CRAZY, "auth", "sending ping to user on cptr:<%x> with ts:[%d]", cptr, now);
+
    memset(resp_buf, 0, sizeof(resp_buf));
    snprintf(resp_buf, sizeof(resp_buf), "{ \"ping\": { \"ts\": %lu } }", now);
    mg_ws_send(c, resp_buf, strlen(resp_buf), WEBSOCKET_OP_TEXT);
 
-   Log(LOG_DEBUG, "auth", "sending ping to user on cptr:<%x> with ts:[%d]", cptr, now);
    // Make sure that timeout will happen if no response
-   cptr->last_ping = now;
    return false;
 }
 
 //
 // Called periodically to remove sessions that have existed too long
 //
-// XXX: We also should do pings for cliebts
 void http_expire_sessions(void) {
    http_client_t *cptr = http_client_list;
    int expired = 0;
 
-   while(cptr != NULL) {
-      if (cptr == NULL) {
-         break;
-      }
-
-      // Boot expired sessions
-      if (cptr->session_expiry <= now) {
-         expired++;
-         time_t last_heard = (now - cptr->last_heard);
-         Log(LOG_AUDIT, "http.auth", "Kicking expired session (%lu sec old, last heard %lu sec ago) for %s",
-             HTTP_SESSION_LIFETIME, last_heard, cptr->chatname);
-         ws_kick_client(cptr, "Login session expired!");
-      // Check for ping timeouts
-      } else if (cptr->last_ping < (now - HTTP_PING_TIMEOUT)) {
-         // Client has timed out
-         Log(LOG_AUDIT, "http.auth", "Client connection <%x> for user %s timed out, disconnecting", cptr, cptr->chatname);
-         ws_kick_client(cptr, "Ping timeout");
-      // Have they been quiet for too long? Send a ping and wait for reply or timeout (above)
-      } else if (cptr->last_heard < (now - HTTP_PING_TIME)) { // Client hasn't been heard from in awhile, send a ping
-         ws_send_ping(cptr);
+   while (cptr != NULL) {
+      if (cptr->is_ws) {
+         // Expired session?
+         if (cptr->session_expiry > 0 && cptr->session_expiry <= now) {
+            expired++;
+            time_t last_heard = now - cptr->last_heard;
+            Log(LOG_AUDIT, "http.auth", "Kicking expired session on cptr:<%x> (%lu sec old, last heard %lu sec ago) for user %s",
+                cptr, HTTP_SESSION_LIFETIME, last_heard, cptr->chatname);
+            ws_kick_client(cptr, "Login session expired!");
+
+         // Ping timeout?
+         } else if (cptr->last_ping != 0 && (now - cptr->last_ping) > HTTP_PING_TIMEOUT) {
+            Log(LOG_AUDIT, "http.auth", "Client conn at cptr:<%x> for user %s timed out, disconnecting", cptr, cptr->chatname);
+            ws_kick_client(cptr, "Ping timeout");
+         // Time to send a ping?
+         } else if (cptr->last_ping == 0 && (now - cptr->last_heard) >= HTTP_PING_TIME) {
+            ws_send_ping(cptr);
+         }
+      } else { // Not websocket
+         if (cptr->connected > 0 && !cptr->session_start && (now - cptr->connected) >= HTTP_AUTH_TIMEOUT) {
+            Log(LOG_AUDIT, "http.auth", "Client at mg_conn:<%x> didn't authenticate in time, booting.", cptr);
+            ws_kick_client(cptr, "Auth timeout");
+         }
       }
+      cptr = cptr->next;
    }
 }
 
diff --git a/http.h b/http.h
index 8169da5..509f4bb 100644
--- a/http.h
+++ b/http.h
@@ -13,8 +13,10 @@
 #define	HTTP_WS_MAX_MSG		65535		// 64kbytes should be enough per message, even with audio frames
 #define	HTTP_SESSION_LIFETIME	12*60*60	// Require a re-login every 12 hours, if still connected
 #define	HTTP_SESSION_REAP_TIME	30		// Every 30 seconds, kill expired sessions
-#define	HTTP_PING_TIME		50		// If we haven't heard from the client in this long, send a ping
+#define	HTTP_AUTH_TIMEOUT	20		// Allow 20 seconds from connection to send login command
+#define	HTTP_PING_TIME		30		// If we haven't heard from the client in this long, send a ping
 #define	HTTP_PING_TIMEOUT	10		// And give them this long to respond
+#define MG_CONN_CPTR(c) (*(http_client_t **)((c)->data))
 
 // HTTP Basic-auth user
 #define	HTTP_MAX_USERS		32		// How many users are allowed in http.users?
@@ -63,6 +65,7 @@ struct http_client {
     bool authenticated;		// Is the user fully logged in?
     bool is_ws;                 // Flag to indicate if it's a WebSocket client
     bool is_ptt;		// Is the user keying up ANY attached rig?
+    time_t connected;		// When was the socket accepted?
     time_t session_expiry;	// When does the session expire?
     time_t session_start;	// When did they login?
     time_t last_heard;		// when a last valid message was heard from client
@@ -91,6 +94,7 @@ extern http_client_t *http_find_client_by_guest_id(int gid);
 extern http_client_t *http_find_client_by_name(const char *name);
 extern const char *http_get_uname(int8_t uid);
 extern void http_dump_clients(void);
+extern void http_expire_sessions(void);					// ping clients, drop pinged out ones, etc
 extern bool http_save_users(const char *filename);			// save active users to config file
 extern char *escape_html(const char *input);
 extern bool ws_send_ping(http_client_t *cptr);
diff --git a/main.c b/main.c
index 3d3a992..0171932 100644
--- a/main.c
+++ b/main.c
@@ -247,13 +247,18 @@ int main(int argc, char **argv) {
       // Redraw the GUI virtual framebuffer, update nextion
       gui_update();
 
+      // Send pings, drop dead connections, etc
+      http_expire_sessions();
+
       // XXX: Check if an LCD/OLED is configured and update it
       // XXX: Check if any mjpeg subscribers exist and prepare a frame for them
+
 #if	defined(USE_MONGOOSE)
       // Process Mongoose HTTP and MQTT events, this should be at the end of loop so all data is ready
       mg_mgr_poll(&mg_mgr, 1000);
 #endif
 
+      // If enabled, calculate loop run time
 #if	defined(USE_PROFILING)
       clock_gettime(CLOCK_MONOTONIC, &loop_end);
       current_time = (loop_end.tv_sec - loop_start.tv_sec) + 
@@ -267,8 +272,8 @@ int main(int argc, char **argv) {
    }
 
 #if	defined(USE_PROFILING)
-   // XXX: Every 5 minutes we should save the loop runtime
-   Log(LOG_DEBUG, "loop", "Average mainloop runtime: %.6f seconds", loop_runtime);
+   // XXX: Every 5 minutes we should log the loop runtime
+//   Log(LOG_INFO, "loop", "Average mainloop runtime: %.6f seconds", loop_runtime);
 #endif // defined(USE_PROFILING)
    host_cleanup();
 
diff --git a/ws.c b/ws.c
index 134ff77..448f2b0 100644
--- a/ws.c
+++ b/ws.c
@@ -54,6 +54,10 @@ void ws_broadcast(struct mg_connection *sender, struct mg_str *msg_data) {
 
    http_client_t *current = http_client_list;
    while (current != NULL) {
+      if (current == NULL || !current->session_start) {
+         break;
+      }
+
       if ((sender == NULL) || (current->is_ws && current->conn != sender)) {
          mg_ws_send(current->conn, msg_data->buf, msg_data->len, WEBSOCKET_OP_TEXT);
       }
@@ -163,10 +167,8 @@ static bool ws_handle_pong(struct mg_ws_message *msg, struct mg_connection *c) {
    bool rv = false;
    char *ts = NULL;
 
-   Log(LOG_DEBUG, "http.ws", "enter ws_handle_pong");
-
    if (c == NULL || msg == NULL || msg->data.buf == NULL) {
-      Log(LOG_DEBUG, "http.ws", "ws_handle_pong got msg <%x> c <%x> data <%x>", msg, c, (msg != NULL ? msg->data.buf : NULL));
+      Log(LOG_CRAZY, "http.ws", "ws_handle_pong got msg <%x> c <%x> data <%x>", msg, c, (msg != NULL ? msg->data.buf : NULL));
       rv = true;
       goto cleanup;
    }
@@ -194,11 +196,11 @@ static bool ws_handle_pong(struct mg_ws_message *msg, struct mg_connection *c) {
    struct mg_str msg_data = msg->data;
    
    if ((ts = mg_json_get_str(msg_data, "$.pong.ts")) == NULL) {
-      Log(LOG_DEBUG, "http.ws", "ws_handle_pong: PONG from user with no timestamp");
+      Log(LOG_WARN, "http.ws", "ws_handle_pong: PONG from user with no timestamp");
       rv = true;
       goto cleanup;
    } else {
-      Log(LOG_DEBUG, "http.ws", "ws_handle_pong: PONG from user %s with ts:|%s|", cptr->chatname, ts);
+      Log(LOG_CRAZY, "http.ws", "ws_handle_pong: PONG from user %s with ts:|%s|", cptr->chatname, ts);
    }
 
    char *endptr;
@@ -206,7 +208,7 @@ static bool ws_handle_pong(struct mg_ws_message *msg, struct mg_connection *c) {
    time_t ts_t = strtoll(ts, &endptr, 10);
 
    if (errno == ERANGE || ts_t < 0 || ts_t > LONG_MAX || *endptr != '\0') {
-      Log(LOG_DEBUG, "http.pong", "Got invalid ts |%s| from client <%x>", ts, c);
+      Log(LOG_WARN, "http.pong", "Got invalid ts |%s| from client <%x>", ts, c);
       rv = true;
       goto cleanup;
    }
@@ -220,7 +222,7 @@ static bool ws_handle_pong(struct mg_ws_message *msg, struct mg_connection *c) {
    } else { // The pong response is valid, update the client's data
       cptr->last_heard = now;
       cptr->last_ping = 0;
-      Log(LOG_DEBUG, "http.pong", "Reset user %s last_heard to now:[%lu] and last_ping to 0", cptr->chatname, now);
+      Log(LOG_CRAZY, "http.pong", "Reset user %s last_heard to now:[%lu] and last_ping to 0", cptr->chatname, now);
    }
 
 cleanup:
@@ -255,7 +257,6 @@ bool ws_handle(struct mg_ws_message *msg, struct mg_connection *c) {
       if (mg_json_get(msg_data, "$.cat", NULL) > 0) {
          return ws_handle_rigctl_msg(msg, c);
       } else if (mg_json_get(msg_data, "$.pong", NULL) > 0) {
-         Log(LOG_DEBUG, "http", "calling ws_handle_pong");
          return ws_handle_pong(msg, c);
       } else if (mg_json_get(msg_data, "$.talk", NULL) > 0) {
          return ws_handle_chat_msg(msg, c);
diff --git a/www/js/webui.js b/www/js/webui.js
index 4e378d6..290fe84 100644
--- a/www/js/webui.js
+++ b/www/js/webui.js
@@ -175,8 +175,7 @@ function ws_connect() {
             // If we make it here, deal with the ping by logging it and replying ASAP
             console.log("Got PING from server with ts", ts, "replying!");
             var newMsg = { pong: { ts: String(ts) } };
-            var msgObj_t = JSON.stringify(newMsg);
-            socket.send(msgObj_t);
+            socket.send(JSON.stringify(newMsg));
          } else if (msgObj.talk) {		// Handle Chat messages
             var cmd = msgObj.talk.cmd;
             var message = msgObj.talk.data;
